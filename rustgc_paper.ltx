%&rustgc_paper_preamble
\endofdump

\begin{document}
\maketitle

\section{Introduction}


\section{Background}

\jake{TODO: Not sure where this stuff goes, or if it will ever make the cut}Rust uses two marker traits: `Send`, and `Sync` for handling concurrency. A type
which implements `Send' is safe to pass between threads, and a type which
implements `Sync' can be referenced from multiple threads at the same time.
These marker traits are implemented transitively; in other words, if a type
`T''s component types all implement `Send' and `Sync', then so will `T'.
Further, if any component type is not `Send' or `Sync', then neither is `T'.
These marker traits allow Rust to catch potential concurrency bugs statically
during type checking.

Rust allows for single-threaded shared ownership using a reference counting
smart pointer, `Rc<T>'. It updates the reference count non-atomically, it
can't implement `Send' because two threads could race when updating the count.

\section{Implementation}

\subsection{Finalisers and Destructors}

\subsection{multi-threaded garbage collection}

In a thread-local GC, roots can only exist in three places: the mutator thread's
call-stack; in registers; and in the static data segment because of static
variables. In a multi-threaded GC, the location of potential roots must also
include the call-stack of every live thread in the program. In addition, some
form of cooperation between mutator threads and the collector is necessary to
ensure that thread stacks are scanned while execution is paused. Rustgc patches
Rust's threading implementation to register each new thread with the collector
on thread creation, and unregister when a thread is destroyed. To facilitate
pausing threads when the collector needs a consistent memory state, Rustgc uses
Boehm's signal spin implementation: when the collector thread wishes to stop the
world, it sends a SIGPWR signal to each registered thread and has them spin in a
signal handler until the collector has finished stopping the the
world.\jake{cite}

This has two key limitations: first, Rustgc can only stop the world during
allocation and calls to \lstinline{force_gc} by a mutator thread; second, it
makes use of unspecified behaviour. The Boehm GC provides implementations for
most platforms, but it is not portable. An implementation where Rust inserts
thread pause safepoints at appropriate locations would largely solve these
issues, with considerable implementation effort.

\subsection{Off-thread Finalisation}

Most VMs implementations run finalisers on a separate finalisation thread [todo
ref]. This is for two main reasons: first, a finaliser which needs to acquire a
lock will deadlock if ran on the same thread which already holds the lock;
second, the asynchronous nature of finalisers can cause interleaving
single-threaded code which races.

For these reasons, Rustgc finalises \lstinline{Gc<T>} values on a dedicated
finalisation thread, which requires \lstinline{T} to implement the
\lstinline{Send} marker trait. Figure~\ref{fig:finaliser_race} shows an example
of how finalising a non-\lstinline{Send} type off-thread is unsound. When
\lstinline{T} does not implement \lstinline{Send}, a collected \lstinline{Gc<T>}
will never be finalised. Rustgc will show a compiler warning lint to the user
explaining this.

Counterintuitively, it is permissable for rustgc to finalise
non-\lstinline{Sync} values off-thread. The \lstinline{Sync} trait is required
to reference a type from multiple threads simultaneuosly.  However, Rustgc's
\textit{dynamic liveness extension} guarantees that \textit{Gc} values are not
reclaimed early, so a value's finaliser will never run while it is still
reachable from a mutator thread. This allows finalisers to to access their
value's data without synchronisation.  \jake{todo: link to subsection about
inline asm which keeps values alive in mir}

This has the ergonomic benefit of allowing off-thread finalisation of GC'd
values with interior mutability using the \lstinline{RefCell} pattern. A
\lstinline{Gc<RefCell<T>>} implements \lstinline{Send} if \lstinline{T} does.
However, \lstinline{RefCell} does not implement \lstinline{Sync} because the
dynamic borrow checking it performs, which is implemented internally as a form
of reference counting, is not thread-safe.

\begin{figure}[t]
\begin{lstlisting}
fn foo() {
    let x = Rc::new(123);
    {
        let y = Gc::new(Rc::clone(rc));
    }

    // Finalises unreachable values off-thread
    force_gc();

    let z = Rc::clone(rc);
}
\end{lstlisting}
\caption{An example of unsoundness when finalising values off-thread. Rust's
\lstinline{Rc} smart pointer is intended to be used for single-threaded
shared ownership so it updates its reference count non-atomically. The
\lstinline{force_gc} call on line 8 will cause the collector to reclaim
\lstinline{y} which is no longer reachable. \lstinline{y} will be finalised
off-thread, resulting in a call to \lstinline{Rc::drop(x)}. This is unsound
because it has the potential to race with the incref on the main-thread on
line 10.}
\label{fig:finaliser_race}
\end{figure}

Rustgc provides an \textit{escape hatch} to support the finalisation of
non-\lstinline{Send} values on the same thread which owns the value. Without
this, patterns such as \lstinline{Gc<Rc<T>>} would be unusable because the
\lstinline{Rc} would never be dropped and always leak memory. \footnote{While no garbage collector
can guarantee that finalisers are run, missed finalisers in Rustgc are rare in
practice, which make the mixing of garbage collected and reference counted
stategies both viable and useful.} The unsafe trait
\lstinline{FinaliseLocally} can be implemented on types, such as \lstinline{Rc}
where thread-local finalisation is desired. \jake{Bikeshed on the trait name}.
This is unsafe because the user must ensure that this trait is only
implemented on a a type where the drop implementation does not access any
data using synchronisation primitives. This is because it is not possible to
guarantee such accesses would be deadlock free due to the non-deterministic
execution of the finaliser.

\cite{jones16garbage}


\bibliographystyle{plain}
\bibliography{bib}

\end{document}
