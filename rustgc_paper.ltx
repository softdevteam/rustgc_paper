%&rustgc_paper_preamble
\endofdump

\begin{document}
\maketitle

\begin{abstract}
Rust is a non-Garbage Collected (GC) language: existing attempts to add GC
support to it are either (subjectively) unergonomic, or (objectively)
unsound or slow. In this paper we show that it is possible to add a fairly
ergonomic GC to Rust, without compromising soundness in safe Rust,
and with reasonable performance. This requires us to expose new APIs
to the user, and to change the Rust compiler, but we do not change the Rust
language itself.
\end{abstract}


\section{Introduction}

Amongst the several ways one can divide programming languages are whether they
are Garbage Collected (GCed) or not. Traditionally, non-GCed languages have
required explicit memory management (e.g~\lstinline{C}'s \lstinline{malloc} /
\lstinline{free} functions). Rust's \emph{ownership types} (a specific instance
of affine types) make it a hybrid: memory management is implicit but Rust does
not use GC. For many portions of many
programs, a Rust program looks identical, from a memory management perspective,
to a GCed language equivalent. However, programs operating on cyclic data
structures are frustrating to write with ownership types. Encodings such as the
use of weak references protect the user from dangling machine pointers, but
cannot prevent memory leaks, or dangling indices.

Because of this, there have been several attempts to add GC to
Rust\footnote{`Premodern' Rust had a reference-counted GC which was removed
gradually from mid 2013 to mid 2014.}. Most are user level libraries
\laurie{cite the ones we know of} which suffer from limitations such as
the inability to apply GC to items defined in external libraries. In contrast,
the Bronze GC~\cite{coblenz21bronze} allows the aliasing of mutable values,
violating Rust's soundness rules. GC in Rust thus remains an unsolved problem.

In this paper we introduce \ourgc, a new point in the Rust GC design space.
\ourgc is fairly ergonomic, does not compromise safe Rust's soundness rules
\jake{not sure how true this is given the Chromium CSS bug},
and has reasonable performance. \ourgc introduces new user-visible APIs and
requires several changes to the Rust compiler \rustc but does not require any
changes to the Rust language. We show that the major challenge for any Rust GC
is Rust's extensive use of \emph{destructors} (or \lstinline{drop} methods) --
simply mapping these to GC finalisers leads to significant performance
problems. We show how many finalisers can be safely optimised away

We validate \ourgc's performance in several different ways: a SOM (a cutdown
Smalltalk) interpreter written specifically to understand how GC in Rust might
work; WLambda, an externally written interpreter to which we have retrofitted
GC; \laurie{we probably need a third example that isn't an intprereter!}.


\section{Background}

\jake{TODO: Not sure where this stuff goes, or if it will ever make the cut}Rust uses two marker traits: `Send`, and `Sync` for handling concurrency. A type
which implements `Send' is safe to pass between threads, and a type which
implements `Sync' can be referenced from multiple threads at the same time.
These marker traits are implemented transitively; in other words, if a type
`T''s component types all implement `Send' and `Sync', then so will `T'.
Further, if any component type is not `Send' or `Sync', then neither is `T'.
These marker traits allow Rust to catch potential concurrency bugs statically
during type checking.

Rust allows for single-threaded shared ownership using a reference counting
smart pointer, `Rc<T>'. It updates the reference count non-atomically, it
can't implement `Send' because two threads could race when updating the count.

\section{Implementation}

\subsection{Finalisers and Destructors}

Rust has support for destructors: a way to run cleanup code when a value goes
out of scope. It does this with a special \lstinline{Drop} trait. A type can
provide an implementation for \lstinline{Drop}, which the compiler will
automatically insert for each value of that type which go out of scope. This is
similar to the RAII (Resource Acquisition is Initialization) idiom in C++, where
class destructors are used for a similar purpose. In Rust parlance, destruction
is known as dropping a value.

The \lstinline{Drop} trait is used extensively by smart pointers. For example,
\lstinline{Box<T>} (a heap allocated pointer to a value of type \lstinline{T})
implements \lstinline{Drop} to free its heap allocation when it goes out
of scope.

\lstinline{Drop} is also a core part of shared ownership in Rust. For example,
when a reference counted smart pointer, \lstinline{Rc}, is dropped, the
reference count of its contents is decremented. If the count hits zero when
dropping an \lstinline{Rc}, the shared contents is also dropped.

Garbage collection inevitably complicates Rust's drop semantics. Unlike
\lstinline{Rc}, shared ownership using \ourgc's \lstinline{Gc} smart pointer
doesn't keep track of how many references there are to its contents. Instead,
the collector will free the contents when it's no longer reachable. If the
contents requires dropping, this now becomes the responsibility of the
collector, because the compiler can't know when this is expected to happen.
\ourgc uses \textit{finalisers} to drop these unreachable values.

Finalisation in \ourgc is unordered between \lstinline{Gc}s. If a field in
\lstinline{Gc<A>} points to \lstinline{Gc<B>}, there is no guarantee that
\lstinline{Gc<A>} will be finalised first. This is so that \ourgc can be used to
create strongly connected cycles which do not leak. When an entire cyclic graph
is unreachable, each node can be finalised independently. This restricts the
drop implementation for types used in \lstinline{Gc}: they must never
dereference fields which point to other \lstinline{Gc}s because those objects
could already be freed at the point of finalisation. In our experiments, we did
not find this restriction too prohibitive, nevertheless, \ourgc can be built
with \textit{topological finalisation} instead. In this configuration, values
are finalised in topological order (\lstinline{Gc<A>} before \lstinline{Gc<B>})
which permits dereferencing through fields pointing to other \lstinline{Gc}s.
However, topological finalisation means that cycles will never be finalised,
which could cause memory leaks. When a finaliser drops a value, its fields are
dropped recursively according to Rust's drop order. Gc itself does not implement
drop, so a finalised value cannot recursively drop any other Gcs that it points
to.

\ourgc, like most VMs implementations, run finalisers on a separate finalisation
thread [todo ref]. This is for two main reasons: first, a finaliser which needs
to acquire a lock will deadlock if ran on the same thread which already holds
the lock; second, the asynchronous nature of finalisers can cause interleaving
single-threaded code which races \jake{Ref boehm sync paper}. However, using a
dedicated thread to finalise values means they must be safe to send between
threads. In Rust, this means that their type must implement the \lstinline{Send}
marker trait. Figure~\ref{fig:finaliser_race} shows how finalising a
non-\lstinline{Send} \lstinline{Rc} value on another thread is unsound. \ourgc's
\lstinline{Gc} smart pointer enforces in the constructor,
\lstinline{Gc<T>::new}, where \lstinline{T} must have a \lstinline{Send} bound.
An additional constructor, \lstinline{Gc<T>::new_unfinalizable}, is available
for non-send values, but they will never be dropped.

The \lstinline{Gc<T>::new} constructor also requires \lstinline{T} to implement
\lstinline{Sync}. This is because even though it's expected that a finaliser is
run on a dead value, it may still be able to mutate a field pointing to a shared
value through a \lstinline{Send} safe smart pointer such as \lstinline{Arc}.
Figure~\ref{fig:finaliser_race_2} shows how finalising a non-\lstinline{Sync}
\lstinline{RefCell} value on another thread is unsound. Unfortunately, this
means that interior mutability in \lstinline{Gc} is limited to the more
expensive sync-safe mutable containers such as RWLock and Mutex. However, since
this kind of soundness bug is rare in practice, (because it requires mixing two
different kinds of shared ownership), we also provide an unsafe constructor
\lstinline{Gc<T>::new_unsynchronised} which accepts non-sync values and does
finalisation \jake{bikeshed on the name} where the user guarantees that Sync
values are not accessed inside the drop method \jake{is this enough?}.


TODO: Talk about sync, but first I need to investigate the soundness.

\begin{figure}[t]
\begin{lstlisting}
fn foo() {
    let rc1 = Rc::new(123);
    {
        let gc = Gc::new(Rc::clone(rc1));
    }

    // Finalises unreachable values off-thread
    force_gc();

    let rc3 = Rc::clone(rc1);
}
\end{lstlisting}
\caption{An example of unsoundness when finalising values off-thread. An
\lstinline{Rc} is meant for single-threaded
shared ownership so it updates its reference count non-atomically. The
\lstinline{force_gc} call on line 8 could reclaim
\lstinline{gc} as it's no longer reachable. \lstinline{gc} will be finalised
    off-thread, which means \lstinline{Rc::drop(x)} will run. This is unsound
    because it has the potential to race with the incref from the
    \lstinline{clone} on the main-thread on
line 10.}
\label{fig:finaliser_race}
\end{figure}

\begin{figure}[t]
\begin{lstlisting}
struct Counter(Arc<RefCell<usize>>);

impl Drop for Counter {
    fn drop(&mut self) {
        *self.0.borrow_mut() += 1;
    }
}


fn main() {
    let arc1 = Counter(Arc::new(RefCell::new(1)));
    {
        let gc1 = Gc::new(Arc::clone(arc1));
    }

    // Finalises 'gc1' off-thread
    force_gc();

    *arc1.borrow_mut() += 1;
    assert_eq!(arc1, 3);
}
\end{lstlisting}
\caption{An example of unsoundness when finalising values off-thread.
    \lstinline{RefCell} is send-safe but not sync safe because dynamic borrow
    checking is done non-atomically. This can cause a race if the main-thread
    mutates at the same time as the finalizer.}
\label{fig:finaliser_race_2}
\end{figure}


\subsection{Finaliser elision}

A \lstinline{Gc<T>} value where \lstinline{T} needs dropping will use a
finalizer to call \lstinline{T::drop}. In Rust, \lstinline{drop} is very common,
so \ourgc ends up using many finalizers. This is not ideal. Programmers who are
familiar with GCed languages know to avoid using finalizers wherever possible.
One of the reasons for this is that invoking finalizers usually comes at a
performance cost. This is certainly true for \ourgc, as we implement finalizers
using the Boehm GC's unordered finalization API, which conservatively marks
objects reachable from a finalizer. This additional marking adds up when many
finalizable objects are present.

Fortunately, we are able to claw back this perfomance hit with an optimisation
we call \textit{finalizer elision}. The key idea is to remove calls to drop
which are used solely to free a value's memory, and instead let the collector
free it. For example, consider the following \lstinline{Gc} which owns a
reference to a boxed \lstinline{usize}.

\begin{lstlisting}
    let a = Box::new(123);
    let gc = Gc::new(a);
\end{lstlisting}

The reference to a heap allocated integer is moved into a \lstinline{Gc}. This
causes a finalizer to drop it when \lstinline{gc} is unreachable. However, the
boxed type is a \lstinline{usize}, which itself does not need dropping. This
means a finalizer was needed to drop the box, and all it did was call
\lstinline{GlobalAlloc:dealloc}. This could be much faster if, instead of using
a finalizer as in the case above, \ourgc recognised that it now solely owns the
heap allocation from the box, and frees it as it does with its own allocation.
This is what finalizer elision does. Of course, it's not possible to remove the
finalizer for drop methods which do things besides deallocation. However, in
practice, we found that this pattern is common enough that the optimisation can
improve performance by at least an order of magnitude \jake{obviously, i'll need
to cite this}.

Finalizer elision is implemented by using traits to change the collector
behaviour based on certain types. We implement these traits on the various
standard library types which allocate (such as Box, RawVec, etc). This means
that for most users, finalizer optimisation will "just work". However, when
users provide their own allocating types, they will need to implement these
traits to make use of finalizer elision.

\subsubsection{Preventing Drop}

\ourgc decides whether values of \lstinline{Gc<T>} need finalising based on the
type of \lstinline{T}. Such analysis can be decided statically and has no
run-time cost. It can be understood as an extension of the existing
\lstinline{needs_drop::<T>} support in Rustc but with some additional rules. It
introduces two new traits: \lstinline{NoFinalize}, and
\lstinline{OnlyFinalizeContents}, to hint to the collector that certain types
won't need finalizing.

A type \lstinline{T} which implements the \lstinline{NoFinalize} trait means
that any \lstinline{Gc<T>} won't need a finaliser. This is true even if
\lstinline{T}, or any of \lstinline{T}'s component types implements
\lstinline{Drop}. However, this does not guarantee that \lstinline{T} will not
be finalised.

\laurie{need to explain OnlyFinalizeContents}

\subsubsection{Using \ourgc to free non-GC'd values}

The second major component of the finalizer elision optimisation is for \ourgc
to free all heap allocations owned by \lstinline{Gc}. This is non-trivial, as these
allocations will have not been originally allocated as garbage-collectable
blocks. Refering back to our original example:

\begin{lstlisting}
    let a = Box::new(123);
    let gc = Gc::new(a);
\end{lstlisting}

\lstinline{a} references a heap allocation created using box. It was allocated
using Rust's global allocator and is not garbage collected. As we did in step
one, Without a finalizer to call Box::drop(box), it will leak memory. For
finalizer elision to work, we need a way to tell the collector that because `gc`
owns `a`, when it frees `gc`, it must also free the allocation at `box`.

This first requires \ourgc to be able to convert a regular non-garbage-collected
heap allocation into one that is freed by the collector. In this paper, we will
refer to a block which is freed by the GC as being managed, and one which is
freed manually as unmanaged. \ourgc uses the Boehm allocator, which provides
malloc calls for both managed allocations (\lstinline{GC_malloc}), and unmanaged
allocations (\lstinline{GC_malloc_uncollectable}). However, it does not allow a
block to be switched between managed and unmanaged once it has already been
allocated. This is mainly because Boehm partitions managed and unmanaged
allocations into distinct pools in memory for implementation reasons.

In \ourgc we modified Boehm to support this. This was done by disabling the
\lstinline{GC_malloc_uncollectable} function for allocating unmanaged blocks,
and instead allocate all blocks in the managed heap with \lstinline{GC_malloc}.
We then make use of a free bit in the object header to denote whether a value is
managed or not. We modify the collector to not only check the mark bit during
sweeping, but also whether or not managed bit is set before freeing. We include
functions, \lstinline{Gc_set_managed} and \lstinline{Gc_set_unmanaged}, for
un/setting the managed bit, and also provide a new malloc function for blocks
where the managed bit is unset by default, \lstinline{GC_malloc_unmanaged}. This
malloc function is used as \ourgc's global allocator, instead of Boehm's
\lstinline{GC_malloc_uncollectable}.

The final piece of the puzzle is for \ourgc to know which heap allocations are
owned by a \lstinline{Gc} in order to switch them to be managed. We do this with
a trait called Collectable, which we implement on all types in the standard
library which use their drop method to call deallocate. The Collectable trait
contains a single method, \lstinline{set_collectable}, which describes how to
switch its value to be managed. For example, the \lstinline{Collectable}
implementation for \lstinline{Box} would look like this:

\begin{lstlisting}
unsafe impl<T, A: Allocator> Collectable for Box<T, A> {
    unsafe fn set_collectable(&self) {
        unsafe {
            // FFI call to custom Boehm function to set managed bit
            set_managed(self.0.as_ptr() as *mut u8);
        }
    }
}
\end{lstlisting}

In this example, we set the managed bit in the allocation used for Box. Similar
trait implementations exist for other types which represent allocation such as
RawVec.

Putting all these pieces together, we use an intrinsic,
\lstinline{make_collectable<T>}, which is called in a \lstinline{Gc<T>::new}
constructor. This intrinsic will recurse through \lstinline{T}, searching for
component types which implement the \lstinline{Collectable} trait. If found,
code is generated to dereference these fields or enum variants and call their
\lstinline{Collectable::set_collectable} methods. This leads to all heap
allocations owned and reachable from the \lstinline{Gc} value being converted to
managed allocations. This process is dynamic, so it incurs a small runtime cost
during \lstinline{Gc} construction.


\subsection{Preventing Premature Finalisation}

One of Rust's strengths is that it prevents dangling pointers by ensuring that
references are never used outside the scope that they are valid for. The
lifetimes of references are checked statically by a part of \lstinline{rustc}
known as the \textit{borrow-checker}. If a value needs dropping,
\lstinline{rustc} will automaticaly insert a call to its \lstinline{Drop::drop}
method once all other references to it are out of scope. This is to ensure
\lstinline{Drop::drop} is not called while the value is still in use, as it is a
destructor, and typically used to clean up a value.

In the same vein, \ourgc must also ensure that \lstinline{Drop::drop} is not
called as part of a finaliser on a value while it is still in use, as to do so
would be unsound. However, finalisers in languages which use tracing garbage
collection may run earlier than expected because of compiler optimisations.
Figure~\ref{fig:finaliser_premature} shows how this can lead to a use-after-free
in safe Rust code. This happens because the compiler may end up clobbering the
stack slot or register containing a garbage-collected reference earlier than
expected if there are no further uses of it. If a collection happens immediately
afterwards, the value may be reclaimed -- and thus finalised -- early. Although
such behaviour is rare in practice, it is possible because like most languages,
Rust's compiler is free to perform any code transformation as long as it does
not change the observable behaviour of the program. In C++ parlance, this is
referred to as the as-if rule.

To prevent early finalisation of GC'd values, \ourgc patches \lstinline{rustc}
to ensure that stack based GC references remain valid for the entire duration of
their stack frame. This is sufficient, because a single reference on the stack
is all that is necessary to keep a GC value alive. \ourgc does this by adding a
MIR transformation pass named \textit{prevent-early-finalization} which runs
before any MIR optimisation passes take place. For MIR bodies (i.e. Rust
functions) which contain GC references, the prevent-early-finalization pass will
append a MIR statement designed to keep alive any GC references at the end of
the block. This MIR statement compiles down to a volatile inline assembly block
designed to inform the optimiser that the values are still being used.
\jake{TODO: More detail here/ explain MIR / Whats a pass etc}

This approach the disadvantage of pessimising code generation in the many cases
where short-lived GC references would not cause problems. In these cases, tying
stack frame is excessive, and future analysis could help eliminate this when it
can be statically determined it is unnecessary.

\jake{ I'm not sure what you mean here.
GC is a Copy type, so we can easily copy around new Gc<T>s from our original
one, but if T is a copy type, then it cant have a Drop method. So if I
understand the question correctly, Copy types bypass these issues because they are not finalizable.}
\laurie{Aha! "GC is a Copy type, so we can easily copy around new Gc<T>s from
our original one, but if T is a copy type, then it cant have a Drop method" OK,
so *this* is why we have to have a MIR pass? Devil's advocate: is this a good
trade-off? If we make Gc non-Copy, we don't need to alter rustc.}
\jake{I think I'm misunderstanding. Whether or not the GC is Copy makes no
difference. It will still need the keepAlive stuff. However, the inner type, T
does make a difference. If T is Copy, then it can't impl Drop, so it won't have
a finaliser, and thus doesn't need its lifetime extending.}
\laurie{my claim is that if Gc (not T) is not-Copy, then we can add a Drop
method to Gc where its `drop' function contains an `asm' statement that
prevents it being moved i.e. is equivalent to your MIR pass. [The obvious
difference is that if Gc is not-Copy, then you have to manually call Gc::clone
everywhere).] I'm not saying this is a good or a bad thing, but I'm trying to
accurately place the MIR pass into context.}
\laurie{My final question is about moves: if I move a GC to another function
what happens? Something like this:}
\begin{lstlisting}
fn foo() -> (Gc, &str) {
    let x = Gc::new(String::from("Hello World"));
    let window = x.as_ref().as_str();
    (x, window)
}
\end{lstlisting}
\laurie{will there be a `KeepAlive' in `foo`, or will it only be in the functions
that call foo?}
\jake{We would add a keepAlive to foo as well as its callers. In this example,
you're correct that it's not necessary because foo will itself keep the Gc alive
long enough because it needs to return it at the end of the call. My MIR pass is not yet
clever enough to detect that though!}

\begin{figure}[t]
\begin{lstlisting}
fn foo() {
    let x = Gc::new(String::from("Hello World"));
    let window = x.as_ref().as_str();

    blast_stack() // inlined into foo

    println!("{}", window); // ERROR: may have been dropped
}

\end{lstlisting}
\caption{An example of unsoundness if a finaliser is allowed to run early.
    Semantically, both \lstinline{x} and \lstinline{window} live until the end
    of \lstinline{foo}. However, the call to \lstinline{blast_stack} may cause
    the optimiser to reuse \lstinline{x}'s stack slot for some other value
    because \lstinline{x} is never used again. If a collection happens during
    the inlined call to \lstinline{blast_stack}, then \lstinline{x} may be
    unreachable and finalised before the end of the call to \lstinline{foo}.
    This would cause \lstinline{Drop::drop} to be called on the
    \lstinline{String} that it manages, freeing its buffer and causing a
    use-after-free when it's accessed on line 7.\laurie{devil's advocate:
    can this example actually go wrong? rust's semantics are that `Gc' can't
    be dropped until the end of `foo', and so the idea that it can be
    dropped earlier seems wrong. For example, the way mutex locks are
    used requires that they're not dropped early. I think you will need
    to include an example that you can show really goes wrong in `real
    life' (i.e. with your pass disabled), possibly involving actual
    machine code output or similar to prove it.}
    \laurie{another idea: I claim that I can achieve the same effect
    as the MIR pass by adding a `Drop' to `Gc' that has the opaque
    `asm' statement in it.}}
\label{fig:finaliser_premature}
\end{figure}


\subsection{Multi-threaded garbage collection}

In single-threaded GC, roots can only exist in three places: the
call stack, registers, and in the program's \emph{data segment} (for static
variables). In a multi-threaded GC, there are multiple call stacks, each
of which must be scanned for roots. This requires threads to cooperate in order
to make sure that this scanning can be done in a consistent fashion. The most
simple form of cooperation is to `stop the world', that is for threads to notice
when a global condition is set, and for them to voluntarily pause themselves.
\boehm uses this strategy, with threads checking whether they should pause
during memory allocation \laurie{GC\_alloc?} or \lstinline{force_gc}.
\jake{subtle difference: the mutator threads themselves don't poll to see if
they should pause. Instead, the collector forces them to by sending them signals
to wait on which are never usually used (e.g. SIGPWR / SIGBUS)} \laurie{ok.
so why do we say they also wait in GC\_alloc and force\_gc ?}

\ourgc patches
Rust's threading implementation to register/register threads on creation/destruction with \boehm.
on thread creation, and unregister when a thread is destroyed. To facilitate
pausing threads when the collector needs a consistent memory state, \ourgc uses
\boehm's signal spin implementation: when the collector thread wishes to stop the
world, it sends a SIGPWR signal to each registered thread and has them spin in a
signal handler until the collector has finished stopping the
world.\jake{cite} \laurie{is this something that \ourgc has added, or is this
spinning what \boehm does without our help?} \jake{This is all boehm}

This has two key limitations: first, \ourgc can only stop the world during
allocation and calls to \lstinline{force_gc} by a mutator thread; second, it
makes use of implementation-defined behaviour because it relies on the target
OS's mechanism for pausing threads. \boehm provides implementations for most
platforms, but it is not portable. An implementation where Rust inserts thread
pause safepoints at appropriate locations would largely solve these issues, with
considerable implementation effort.

\subsection{Off-thread Finalisation}

Most VMs implementations run finalisers on a separate finalisation thread [todo
ref]. This is for two main reasons: first, a finaliser which needs to acquire a
lock will deadlock if ran on the same thread which already holds the lock;
second, the asynchronous nature of finalisers can cause interleaving
single-threaded code which races.

For these reasons, \ourgc finalises \lstinline{Gc<T>} values on a dedicated
finalisation thread, which requires \lstinline{T} to implement the
\lstinline{Send} marker trait. Figure~\ref{fig:finaliser_race} shows an example
of how finalising a non-\lstinline{Send} type off-thread is unsound. When
\lstinline{T} does not implement \lstinline{Send}, a collected \lstinline{Gc<T>}
will never be finalised. \ourgc will show a compiler warning lint to the user
explaining this.

Counterintuitively, it is permissable for rustgc to finalise
non-\lstinline{Sync} values off-thread. The \lstinline{Sync} trait is required
to reference a type from multiple threads simultaneuosly.  However, \ourgc's
\textit{dynamic liveness extension} guarantees that \textit{Gc} values are not
reclaimed early, so a value's finaliser will never run while it is still
reachable from a mutator thread. This allows finalisers to to access their
value's data without synchronisation.  \jake{todo: link to subsection about
inline asm which keeps values alive in mir}

This has the ergonomic benefit of allowing off-thread finalisation of GC'd
values with interior mutability using the \lstinline{RefCell} pattern. A
\lstinline{Gc<RefCell<T>>} implements \lstinline{Send} if \lstinline{T} does.
However, \lstinline{RefCell} does not implement \lstinline{Sync} because the
dynamic borrow checking it performs, which is implemented internally as a form
of reference counting, is not thread-safe.

\ourgc provides an \textit{escape hatch} to support the finalisation of
non-\lstinline{Send} values on the same thread which owns the value. Without
this, patterns such as \lstinline{Gc<Rc<T>>} would be unusable because the
\lstinline{Rc} would never be dropped and always leak memory. \footnote{While no garbage collector
can guarantee that finalisers are run, missed finalisers in \ourgc are rare in
practice, which make the mixing of garbage collected and reference counted
stategies both viable and useful.} The unsafe trait
\lstinline{FinaliseLocally} can be implemented on types, such as \lstinline{Rc}
where thread-local finalisation is desired. \jake{Bikeshed on the trait name}.
This is unsafe because the user must ensure that this trait is only
implemented on a a type where the drop implementation does not access any
data using synchronisation primitives. This is because it is not possible to
guarantee such accesses would be deadlock free due to the non-deterministic
execution of the finaliser.

\cite{jones16garbage}


\bibliographystyle{plain}
\bibliography{bib}

\end{document}
