%&rustgc_paper_preamble
\endofdump

\begin{document}
\maketitle

\begin{abstract}
Rust is a non-garbage collected language and existing attempts to add GC
support to it are either (subjectively) unergonomic, or (objectively)
unsound or slow. In this paper we show that it is possible to add a fairly
ergonomic GC to Rust, without compromising soundness in safe Rust,
and with reasonable performance. This does require us to change the Rust
compiler and expose new APIs to the user, but we do not change the Rust
language itself.
\end{abstract}


\section{Introduction}

Amongst the several ways one can divide programming languages are whether they
are Garbage Collected (GCed) or not. Traditionally, non-GCed languages have
required explicit memory management (e.g~\lstinline{C}'s \lstinline{malloc} /
\lstinline{free} functions). Rust's use of ownership types is a hybrid: most
memory management is implicit but it is not GCed. For many portions of many
programs, a Rust program looks identical, from a memory management perspective,
to a GCed language equivalent. However, some kinds of programs, such as
those operating on cyclic data structures, are frustrating to write with
ownership types. There are various ways of encoding such structures, but at
some point the user has to handle some aspects of the problem manually.
Assuming the user stays in \emph{safe Rust} (i.e.~does not use, directly
or indirectly, the \lstinline{unsafe} construct) they are protected
from some traditional mistakes such as dereferencing a dangling machine pointer,
but Rust cannot help prevent memory leaks or other consequences of the encoding.

Because of this, there have already been several attempts to add GC to
Rust\footnote{`Premodern' Rust had a reference-counted GC which was removed
gradually from mid 2013 to mid 2014.}. Most are user level libraries
\laurie{cite the ones we know of, and outline the
major issues e.g.~can't GC across libraries etc.}. The Bronze
GC~\cite{coblenz21bronze} in contrast, performs GC at a lower-level (using LLVM
\lstinline{StackMaps}) but allows the aliasing of mutable values, violating
safe Rust's soundness rules.

In this paper we introduce \ourgc, an ergonomic GC, that preserves soundness
in safe Rust, while not unduly compromising performance. We show that it is
possible to provide a fully-featured GC that does not changes the rules of
safe Rust, though we also show that it is necessary to change the rules of
unsafe Rust. Crucially, all user-visible aspects of the GC are exposed via
standard APIs though we make several changes to \lstinline{rustc} (the Rust
compiler) to make GC work. \laurie{what are the major Rust-specific challenges?
destruction, clearly, and ... ?}


\section{Background}

\jake{TODO: Not sure where this stuff goes, or if it will ever make the cut}Rust uses two marker traits: `Send`, and `Sync` for handling concurrency. A type
which implements `Send' is safe to pass between threads, and a type which
implements `Sync' can be referenced from multiple threads at the same time.
These marker traits are implemented transitively; in other words, if a type
`T''s component types all implement `Send' and `Sync', then so will `T'.
Further, if any component type is not `Send' or `Sync', then neither is `T'.
These marker traits allow Rust to catch potential concurrency bugs statically
during type checking.

Rust allows for single-threaded shared ownership using a reference counting
smart pointer, `Rc<T>'. It updates the reference count non-atomically, it
can't implement `Send' because two threads could race when updating the count.

\section{Implementation}

\subsection{Finalisers and Destructors}
\subsubsection{Preventing Premature Finalisation}

One of Rust's strengths is that it prevents dangling pointers by ensuring that
references are never used outside the scope that they are valid for. The
lifetimes of references are checked statically by a part of \lstinline{rustc}
known as the \textit{borrow-checker}. If a value needs dropping,
\lstinline{rustc} will automaticaly insert a call to its \lstinline{Drop::drop}
method once all other references to it are out of scope. This is to ensure
\lstinline{Drop::drop} is not called while the value is still in use, as it is a
destructor, and typically used to clean up a value.

In the same vein, \ourgc must also ensure that \lstinline{Drop::drop} is not
called as part of a finaliser on a value while it is still in use, as to do so
would be unsound. However, finalisers in languages which use tracing garbage
collection may run earlier than expected because of compiler optimisations.
Figure~\ref{fig:finaliser_premature} shows how this can lead to a use-after-free
in safe Rust code. This happens because the compiler may end up clobbering the
stack slot or register containing a garbage-collected reference earlier than
expected if there are no further uses of it. If a collection happens immediately
afterwards, the value may be reclaimed -- and thus finalised -- early. Although
such behaviour is rare in practice, it is possible because like most languages,
Rust's compiler is free to perform any code transformation as long as it does
not change the observable behaviour of the program. In C++ parlance, this is
referred to as the as-if rule.

To prevent early finalisation of GC'd values, \ourgc patches \lstinline{rustc}
to ensure that stack based GC references remain valid for the entire duration of
their stack frame. This is sufficient, because a single reference on the stack
is all that is necessary to keep a GC value alive. \ourgc does this by adding a
MIR transformation pass named \textit{prevent-early-finalization} which runs
before any MIR optimisation passes take place. For MIR bodies (i.e. Rust
functions) which contain GC references, the prevent-early-finalization pass will
append a MIR statement designed to keep alive any GC references at the end of
the block. This MIR statement compiles down to a volatile inline assembly block
designed to inform the optimiser that the values are still being used.
\jake{TODO: More detail here/ explain MIR / Whats a pass etc}

This approach the disadvantage of pessimising code generation in the many cases
where short-lived GC references would not cause problems. In these cases, tying
stack frame is excessive, and future analysis could help eliminate this when it
can be statically determined it is unnecessary.

\laurie{I think there's something unstated in this subsection, and particularly
the example below, that's worth checking on. My first reaction was ``in a
conservative GC, this example doesn't show a problem.'' But then I realised
that the problem is presumably because `String' is a separate heap-allocated
thingy. Thus having a reference to the `String' alone doesn't force the `Gc' to
stay alive, so the `Gc' will be collected, the finaliser run, and the `String'
deallocated, even though the `\&str' is still in use. Correct?}
\laurie{If so, my next question was ``is the `keep alive until the end of the
block' thing enough?'' At first I wasn't sure about that either, but I think
the point is that `Gc::as\_ref' must return a reference, so that prevents
someone in the above example returning a `\&str' to the caller (the borrow
checker will complain that it's tied to the `Gc's lifetime).}
\laurie{Another thing I then wondered about was `Copy' types: if I can
`Copy' something out of a `Gc's inner contents then could I do something
weird that would break in safe Rust? The only example I can come up with
is a silly variant of `Rc' that would deallocate memory when one of
the `Copy'd instances is dropped. But that would be unsafe in non-GC
Rust, so I don't see that as a problem.}
\laurie{My final question is about moves: if I move a GC to another function
what happens? Something like this:}
\begin{lstlisting}
fn foo() -> (Gc, &str) {
    let x = Gc::new(String::from("Hello World"));
    let window = x.as_ref().as_str();
    (x, window)
}
\end{lstlisting}
\laurie{will there be a `KeepAlive' in `foo`, or will it only be in the functions
that call foo?}

\begin{figure}[t]
\begin{lstlisting}
fn foo() {
    let x = Gc::new(String::from("Hello World"));
    let window = x.as_ref().as_str();

    blast_stack() // inlined into foo

    println!("{}", window); // ERROR: may have been dropped
}

\end{lstlisting}
\caption{An example of unsoundness if a finaliser is allowed to run early.
    Semantically, both \lstinline{x} and \lstinline{window} live until the end
    of \lstinline{foo}. However, the call to \lstinline{blast_stack} may cause
    the optimiser to reuse \lstinline{x}'s stack slot for some other value
    because \lstinline{x} is never used again. If a collection happens during
    the inlined call to \lstinline{blast_stack}, then \lstinline{x} may be
    unreachable and finalised before the end of the call to \lstinline{foo}.
    This would cause \lstinline{Drop::drop} to be called on the
    \lstinline{String} that it manages, freeing its buffer and causing a
    use-after-free when it's accessed on line 7.\laurie{devil's advocate:
    can this example actually go wrong? rust's semantics are that `Gc' can't
    be dropped until the end of `foo', and so the idea that it can be
    dropped earlier seems wrong. For example, the way mutex locks are
    used requires that they're not dropped early. I think you will need
    to include an example that you can show really goes wrong in `real
    life' (i.e. with your pass disabled), possibly involving actual
    machine code output or similar to prove it.}}
\label{fig:finaliser_premature}
\end{figure}


\subsection{Multi-threaded garbage collection}

In single-threaded GC, roots can only exist in three places: the
call stack, registers, and in the program's \emph{data segment} (for static
variables). In a multi-threaded GC, there are multiple call stacks, each
of which must be scanned for roots. This requires threads to cooperate in order
to make sure that this scanning can be done in a consistent fashion. The most
simple form of cooperation is to `stop the world', that is for threads to notice
when a global condition is set, and for them to voluntarily pause themselves.
\boehm uses this strategy, with threads checking whether they should pause
during memory allocation \laurie{GC\_alloc?} or \lstinline{force_gc}.
\jake{subtle difference: the mutator threads themselves don't poll to see if
they should pause. Instead, the collector forces them to by sending them signals
to wait on which are never usually used (e.g. SIGPWR / SIGBUS)} \laurie{ok.
so why do we say they also wait in GC\_alloc and force\_gc ?}

\ourgc patches
Rust's threading implementation to register/register threads on creation/destruction with \boehm.
on thread creation, and unregister when a thread is destroyed. To facilitate
pausing threads when the collector needs a consistent memory state, \ourgc uses
\boehm's signal spin implementation: when the collector thread wishes to stop the
world, it sends a SIGPWR signal to each registered thread and has them spin in a
signal handler until the collector has finished stopping the
world.\jake{cite} \laurie{is this something that \ourgc has added, or is this
spinning what \boehm does without our help?} \jake{This is all boehm}

This has two key limitations: first, \ourgc can only stop the world during
allocation and calls to \lstinline{force_gc} by a mutator thread; second, it
makes use of implementation-defined behaviour because it relies on the target
OS's mechanism for pausing threads. \boehm provides implementations for most
platforms, but it is not portable. An implementation where Rust inserts thread
pause safepoints at appropriate locations would largely solve these issues, with
considerable implementation effort.

\subsection{Off-thread Finalisation}

Most VMs implementations run finalisers on a separate finalisation thread [todo
ref]. This is for two main reasons: first, a finaliser which needs to acquire a
lock will deadlock if ran on the same thread which already holds the lock;
second, the asynchronous nature of finalisers can cause interleaving
single-threaded code which races.

For these reasons, \ourgc finalises \lstinline{Gc<T>} values on a dedicated
finalisation thread, which requires \lstinline{T} to implement the
\lstinline{Send} marker trait. Figure~\ref{fig:finaliser_race} shows an example
of how finalising a non-\lstinline{Send} type off-thread is unsound. When
\lstinline{T} does not implement \lstinline{Send}, a collected \lstinline{Gc<T>}
will never be finalised. \ourgc will show a compiler warning lint to the user
explaining this.

Counterintuitively, it is permissable for rustgc to finalise
non-\lstinline{Sync} values off-thread. The \lstinline{Sync} trait is required
to reference a type from multiple threads simultaneuosly.  However, \ourgc's
\textit{dynamic liveness extension} guarantees that \textit{Gc} values are not
reclaimed early, so a value's finaliser will never run while it is still
reachable from a mutator thread. This allows finalisers to to access their
value's data without synchronisation.  \jake{todo: link to subsection about
inline asm which keeps values alive in mir}

This has the ergonomic benefit of allowing off-thread finalisation of GC'd
values with interior mutability using the \lstinline{RefCell} pattern. A
\lstinline{Gc<RefCell<T>>} implements \lstinline{Send} if \lstinline{T} does.
However, \lstinline{RefCell} does not implement \lstinline{Sync} because the
dynamic borrow checking it performs, which is implemented internally as a form
of reference counting, is not thread-safe.

\begin{figure}[t]
\begin{lstlisting}
fn foo() {
    let x = Rc::new(123);
    {
        let y = Gc::new(Rc::clone(rc));
    }

    // Finalises unreachable values off-thread
    force_gc();

    let z = Rc::clone(rc);
}
\end{lstlisting}
\caption{An example of unsoundness when finalising values off-thread. Rust's
\lstinline{Rc} smart pointer is intended to be used for single-threaded
shared ownership so it updates its reference count non-atomically. The
\lstinline{force_gc} call on line 8 will cause the collector to reclaim
\lstinline{y} which is no longer reachable. \lstinline{y} will be finalised
off-thread, resulting in a call to \lstinline{Rc::drop(x)}. This is unsound
because it has the potential to race with the incref on the main-thread on
line 10.}
\label{fig:finaliser_race}
\end{figure}

\ourgc provides an \textit{escape hatch} to support the finalisation of
non-\lstinline{Send} values on the same thread which owns the value. Without
this, patterns such as \lstinline{Gc<Rc<T>>} would be unusable because the
\lstinline{Rc} would never be dropped and always leak memory. \footnote{While no garbage collector
can guarantee that finalisers are run, missed finalisers in \ourgc are rare in
practice, which make the mixing of garbage collected and reference counted
stategies both viable and useful.} The unsafe trait
\lstinline{FinaliseLocally} can be implemented on types, such as \lstinline{Rc}
where thread-local finalisation is desired. \jake{Bikeshed on the trait name}.
This is unsafe because the user must ensure that this trait is only
implemented on a a type where the drop implementation does not access any
data using synchronisation primitives. This is because it is not possible to
guarantee such accesses would be deadlock free due to the non-deterministic
execution of the finaliser.

\cite{jones16garbage}


\bibliographystyle{plain}
\bibliography{bib}

\end{document}
