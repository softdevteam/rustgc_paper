%&rustgc_paper_preamble
\endofdump

\begin{document}
\maketitle

\begin{abstract}
Rust is a non-Garbage Collected (GC) language: existing attempts to add GC
support to it are either (subjectively) unergonomic, or (objectively)
unsound or slow. In this paper we show that it is possible to add a fairly
ergonomic GC to Rust, without compromising soundness in safe Rust,
and with reasonable performance. This requires us to expose new APIs
to the user, and to change the Rust compiler, but we do not change the Rust
language itself.
\end{abstract}


\section{Introduction}

Amongst the several ways one can divide programming languages are whether they
are Garbage Collected (GCed) or not. Traditionally, non-GCed languages have
required explicit memory management (e.g~\lstinline{C}'s \lstinline{malloc} /
\lstinline{free} functions). Rust's \emph{ownership types} (a specific instance
of affine types) make it a hybrid: memory management is implicit but Rust does
not use GC. For many portions of many
programs, a Rust program looks identical, from a memory management perspective,
to a GCed language equivalent. However, programs operating on cyclic data
structures are frustrating to write with ownership types. Encodings such as the
use of weak references protect the user from dangling machine pointers, but
cannot prevent memory leaks, or dangling indices.

Because of this, there have been several attempts to add GC to
Rust\footnote{`Premodern' Rust had a reference-counted GC which was removed
gradually from mid 2013 to mid 2014.}. Most are user level libraries
\laurie{cite the ones we know of} which suffer from limitations such as
the inability to apply GC to items defined in external libraries. In contrast,
the Bronze GC~\cite{coblenz21bronze} allows the aliasing of mutable values,
violating Rust's soundness rules. GC in Rust thus remains an unsolved problem.

In this paper we introduce \ourgc, a new point in the Rust GC design space.
\ourgc is fairly ergonomic, does not compromise safe Rust's soundness rules,
and has reasonable performance. \ourgc introduces new user-visible APIs and
requires several changes to the Rust compiler \rustc but does not require any
changes to the Rust language. We show that the major challenge for any Rust GC
is Rust's extensive use of \emph{destructors} (or \lstinline{drop} methods) --
simply mapping these to GC finalisers leads to significant performance
problems. We show how many finalisers can be safely optimised away

We validate \ourgc's performance in several different ways: a SOM (a cutdown
Smalltalk) interpreter written specifically to understand how GC in Rust might
work; WLambda, an externally written interpreter to which we have retrofitted
GC; \laurie{we probably need a third example that isn't an intprereter!}.


\section{Background}

\jake{TODO: Not sure where this stuff goes, or if it will ever make the cut}Rust uses two marker traits: `Send`, and `Sync` for handling concurrency. A type
which implements `Send' is safe to pass between threads, and a type which
implements `Sync' can be referenced from multiple threads at the same time.
These marker traits are implemented transitively; in other words, if a type
`T''s component types all implement `Send' and `Sync', then so will `T'.
Further, if any component type is not `Send' or `Sync', then neither is `T'.
These marker traits allow Rust to catch potential concurrency bugs statically
during type checking.

Rust allows for single-threaded shared ownership using a reference counting
smart pointer, `Rc<T>'. It updates the reference count non-atomically, it
can't implement `Send' because two threads could race when updating the count.

\section{Implementation}

\subsection{Finalisers and Destructors}

Rust has support for destructors: a way to run cleanup code when a value goes
out of scope. It does this with a special \lstinline{Drop} trait. A type can
provide an implementation for \lstinline{Drop}, which the compiler will
automatically insert for each value of that type which go out of scope. This is
similar to the RAII (Resource Acquisition is Initialization) idiom in C++, where
class destructors are used for a similar purpose. In Rust parlance, destruction
is known as dropping a value.

The \lstinline{Drop} trait is used extensively by smart pointers. For example,
\lstinline{Box<T>} (a heap allocated pointer to a value of type \lstinline{T})
implements \lstinline{Drop} to free its heap allocation when it goes out
of scope.

\lstinline{Drop} is also a core part of shared ownership in Rust. For example,
when a reference counted smart pointer, \lstinline{Rc}, is dropped, the
reference count of its contents is decremented. If the count hits zero when
dropping an \lstinline{Rc}, the shared contents is also dropped.

Garbage collection inevitably complicates Rust's drop semantics. Unlike
\lstinline{Rc}, shared ownership using \ourgc's \lstinline{Gc} smart pointer
doesn't keep track of how many references there are to its contents. Instead,
the collector will free the contents when it's no longer reachable. If the
contents requires dropping, this now becomes the responsibility of the
collector, because the compiler can't know when this is expected to happen.
\ourgc uses \textit{finalisers} to drop these unreachable values.

Finalisation in \ourgc is unordered between \lstinline{Gc}s. If a field in
\lstinline{Gc<A>} points to \lstinline{Gc<B>}, there is no guarantee that
\lstinline{Gc<A>} will be finalised first. This is so that \ourgc can be used to
create strongly connected cycles which do not leak. When an entire cyclic graph
is unreachable, each node can be finalised independently. This restricts the
drop implementation for types used in \lstinline{Gc}: they must never
dereference fields which point to other \lstinline{Gc}s because those objects
could already be freed at the point of finalisation. In our experiments, we did
not find this restriction too prohibitive, nevertheless, \ourgc can be built
with \textit{topological finalisation} instead. In this configuration, values
are finalised in topological order (\lstinline{Gc<A>} before \lstinline{Gc<B>})
which permits dereferencing through fields pointing to other \lstinline{Gc}s.
However, topological finalisation means that cycles will never be finalised,
which could cause memory leaks. When a finaliser drops a value, its fields are
dropped recursively according to Rust's drop order. Gc itself does not implement
drop, so a finalised value cannot recursively drop any other Gcs that it points
to.

\ourgc, like most VMs implementations, run finalisers on a separate finalisation
thread [todo ref]. This is for two main reasons: first, a finaliser which needs
to acquire a lock will deadlock if ran on the same thread which already holds
the lock; second, the asynchronous nature of finalisers can cause interleaving
single-threaded code which races \jake{Ref boehm sync paper}. However, using a
dedicated thread to finalise values means they must be safe to send between
threads. In Rust, this means that their type must implement the \lstinline{Send}
marker trait. Figure~\ref{fig:finaliser_race} shows how finalising a
non-\lstinline{Send} \lstinline{Rc} value on another thread is unsound. \ourgc's
\lstinline{Gc} smart pointer enforces in the constructor,
\lstinline{Gc<T>::new}, where \lstinline{T} must have a \lstinline{Send} bound.
An additional constructor, \lstinline{Gc<T>::new_unfinalizable}, is available
for non-send values, but they will never be dropped.

TODO: Talk about sync, but first I need to investigate the soundness.

\begin{figure}[t]
\begin{lstlisting}
fn foo() {
    let rc1 = Rc::new(123);
    {
        let gc = Gc::new(Rc::clone(rc1));
    }

    // Finalises unreachable values off-thread
    force_gc();

    let rc3 = Rc::clone(rc1);
}
\end{lstlisting}
\caption{An example of unsoundness when finalising values off-thread. An
\lstinline{Rc} is meant for single-threaded
shared ownership so it updates its reference count non-atomically. The
\lstinline{force_gc} call on line 8 could reclaim
\lstinline{gc} as it's no longer reachable. \lstinline{gc} will be finalised
    off-thread, which means \lstinline{Rc::drop(x)} will run. This is unsound
    because it has the potential to race with the incref from the
    \lstinline{clone} on the main-thread on
line 10.}
\label{fig:finaliser_race}
\end{figure}


\subsubsection{Finaliser elision}

\ourgc will finalise dead \lstinline{Gc<T>} values by calling the
\lstinline{T::drop} method (if one exists). However, these drop calls can't be
inserted automatically by the compiler because the lifetime of a \lstinline{Gc}
is only known dynamically \laurie{devil's advocate: they can be inserted
automatically as, effectively, reference counting}: it is freed when the
collector determines it is
unreachable. Instead, \lstinline{T::drop} is enqueued for finalization
dynamically. Furthermore, if a Gc value holds a reference to a non-Gc'd value,
then a finalizer must be used to call the non-Gc'd value's destructor. This is
expensive because it can lead to a finalisation bottleneck in object graphs with
edges between different kinds of values.

\ourgc tries to reduce the number of finalisers needed with an optimisation it
calls \textit{finaliser elision}. The key observation is that \lstinline{Drop}
methods in Rust are mainly used to free resources. In particular, types such as
\lstinline{Box} and \lstinline{RawVec} use \lstinline{Drop} to deallocate their
dynamic memory. When such types are owned by a reference from a \lstinline{Gc},
the collector can also take responsibility for freeing their memory, instead of
the much slower approach of using a finaliser to call their \lstinline{Drop}
method. Of course, this is not always possible: if a type's \lstinline{Drop}
method does anything more complicated than just freeing memory, it must still be
called using a finaliser.

\ourgc decides whether values of \lstinline{Gc<T>} need finalising based on the
type of \lstinline{T}. Such analysis can be decided statically and has no
run-time cost. It can be understood as an extension of the existing
\lstinline{needs_drop::<T>} support in Rustc but with some additional rules. It
introduces two new traits: \lstinline{NoFinalize}, and
\lstinline{OnlyFinalizeContents}, to hint to the collector that certain types
won't need finalizing.

A type \lstinline{T} which implements the \lstinline{NoFinalize} trait means
that any \lstinline{Gc<T>} won't need a finaliser. This is true even if
\lstinline{T}, or any of \lstinline{T}'s component types implements
\lstinline{Drop}. However, this does not guarantee that \lstinline{T} will not
be finalised.

\laurie{need to explain OnlyFinalizeContents}




\subsubsection{Preventing Premature Finalisation}

One of Rust's strengths is that it prevents dangling pointers by ensuring that
references are never used outside the scope that they are valid for. The
lifetimes of references are checked statically by a part of \lstinline{rustc}
known as the \textit{borrow-checker}. If a value needs dropping,
\lstinline{rustc} will automaticaly insert a call to its \lstinline{Drop::drop}
method once all other references to it are out of scope. This is to ensure
\lstinline{Drop::drop} is not called while the value is still in use, as it is a
destructor, and typically used to clean up a value.

In the same vein, \ourgc must also ensure that \lstinline{Drop::drop} is not
called as part of a finaliser on a value while it is still in use, as to do so
would be unsound. However, finalisers in languages which use tracing garbage
collection may run earlier than expected because of compiler optimisations.
Figure~\ref{fig:finaliser_premature} shows how this can lead to a use-after-free
in safe Rust code. This happens because the compiler may end up clobbering the
stack slot or register containing a garbage-collected reference earlier than
expected if there are no further uses of it. If a collection happens immediately
afterwards, the value may be reclaimed -- and thus finalised -- early. Although
such behaviour is rare in practice, it is possible because like most languages,
Rust's compiler is free to perform any code transformation as long as it does
not change the observable behaviour of the program. In C++ parlance, this is
referred to as the as-if rule.

To prevent early finalisation of GC'd values, \ourgc patches \lstinline{rustc}
to ensure that stack based GC references remain valid for the entire duration of
their stack frame. This is sufficient, because a single reference on the stack
is all that is necessary to keep a GC value alive. \ourgc does this by adding a
MIR transformation pass named \textit{prevent-early-finalization} which runs
before any MIR optimisation passes take place. For MIR bodies (i.e. Rust
functions) which contain GC references, the prevent-early-finalization pass will
append a MIR statement designed to keep alive any GC references at the end of
the block. This MIR statement compiles down to a volatile inline assembly block
designed to inform the optimiser that the values are still being used.
\jake{TODO: More detail here/ explain MIR / Whats a pass etc}

This approach the disadvantage of pessimising code generation in the many cases
where short-lived GC references would not cause problems. In these cases, tying
stack frame is excessive, and future analysis could help eliminate this when it
can be statically determined it is unnecessary.

\jake{ I'm not sure what you mean here.
GC is a Copy type, so we can easily copy around new Gc<T>s from our original
one, but if T is a copy type, then it cant have a Drop method. So if I
understand the question correctly, Copy types bypass these issues because they are not finalizable.}
\laurie{Aha! "GC is a Copy type, so we can easily copy around new Gc<T>s from
our original one, but if T is a copy type, then it cant have a Drop method" OK,
so *this* is why we have to have a MIR pass? Devil's advocate: is this a good
trade-off? If we make Gc non-Copy, we don't need to alter rustc.}
\jake{I think I'm misunderstanding. Whether or not the GC is Copy makes no
difference. It will still need the keepAlive stuff. However, the inner type, T
does make a difference. If T is Copy, then it can't impl Drop, so it won't have
a finaliser, and thus doesn't need its lifetime extending.}
\laurie{my claim is that if Gc (not T) is not-Copy, then we can add a Drop
method to Gc where its `drop' function contains an `asm' statement that
prevents it being moved i.e. is equivalent to your MIR pass. [The obvious
difference is that if Gc is not-Copy, then you have to manually call Gc::clone
everywhere).] I'm not saying this is a good or a bad thing, but I'm trying to
accurately place the MIR pass into context.}
\laurie{My final question is about moves: if I move a GC to another function
what happens? Something like this:}
\begin{lstlisting}
fn foo() -> (Gc, &str) {
    let x = Gc::new(String::from("Hello World"));
    let window = x.as_ref().as_str();
    (x, window)
}
\end{lstlisting}
\laurie{will there be a `KeepAlive' in `foo`, or will it only be in the functions
that call foo?}
\jake{We would add a keepAlive to foo as well as its callers. In this example,
you're correct that it's not necessary because foo will itself keep the Gc alive
long enough because it needs to return it at the end of the call. My MIR pass is not yet
clever enough to detect that though!}

\begin{figure}[t]
\begin{lstlisting}
fn foo() {
    let x = Gc::new(String::from("Hello World"));
    let window = x.as_ref().as_str();

    blast_stack() // inlined into foo

    println!("{}", window); // ERROR: may have been dropped
}

\end{lstlisting}
\caption{An example of unsoundness if a finaliser is allowed to run early.
    Semantically, both \lstinline{x} and \lstinline{window} live until the end
    of \lstinline{foo}. However, the call to \lstinline{blast_stack} may cause
    the optimiser to reuse \lstinline{x}'s stack slot for some other value
    because \lstinline{x} is never used again. If a collection happens during
    the inlined call to \lstinline{blast_stack}, then \lstinline{x} may be
    unreachable and finalised before the end of the call to \lstinline{foo}.
    This would cause \lstinline{Drop::drop} to be called on the
    \lstinline{String} that it manages, freeing its buffer and causing a
    use-after-free when it's accessed on line 7.\laurie{devil's advocate:
    can this example actually go wrong? rust's semantics are that `Gc' can't
    be dropped until the end of `foo', and so the idea that it can be
    dropped earlier seems wrong. For example, the way mutex locks are
    used requires that they're not dropped early. I think you will need
    to include an example that you can show really goes wrong in `real
    life' (i.e. with your pass disabled), possibly involving actual
    machine code output or similar to prove it.}
    \laurie{another idea: I claim that I can achieve the same effect
    as the MIR pass by adding a `Drop' to `Gc' that has the opaque
    `asm' statement in it.}}
\label{fig:finaliser_premature}
\end{figure}


\subsection{Multi-threaded garbage collection}

In single-threaded GC, roots can only exist in three places: the
call stack, registers, and in the program's \emph{data segment} (for static
variables). In a multi-threaded GC, there are multiple call stacks, each
of which must be scanned for roots. This requires threads to cooperate in order
to make sure that this scanning can be done in a consistent fashion. The most
simple form of cooperation is to `stop the world', that is for threads to notice
when a global condition is set, and for them to voluntarily pause themselves.
\boehm uses this strategy, with threads checking whether they should pause
during memory allocation \laurie{GC\_alloc?} or \lstinline{force_gc}.
\jake{subtle difference: the mutator threads themselves don't poll to see if
they should pause. Instead, the collector forces them to by sending them signals
to wait on which are never usually used (e.g. SIGPWR / SIGBUS)} \laurie{ok.
so why do we say they also wait in GC\_alloc and force\_gc ?}

\ourgc patches
Rust's threading implementation to register/register threads on creation/destruction with \boehm.
on thread creation, and unregister when a thread is destroyed. To facilitate
pausing threads when the collector needs a consistent memory state, \ourgc uses
\boehm's signal spin implementation: when the collector thread wishes to stop the
world, it sends a SIGPWR signal to each registered thread and has them spin in a
signal handler until the collector has finished stopping the
world.\jake{cite} \laurie{is this something that \ourgc has added, or is this
spinning what \boehm does without our help?} \jake{This is all boehm}

This has two key limitations: first, \ourgc can only stop the world during
allocation and calls to \lstinline{force_gc} by a mutator thread; second, it
makes use of implementation-defined behaviour because it relies on the target
OS's mechanism for pausing threads. \boehm provides implementations for most
platforms, but it is not portable. An implementation where Rust inserts thread
pause safepoints at appropriate locations would largely solve these issues, with
considerable implementation effort.

\subsection{Off-thread Finalisation}

Most VMs implementations run finalisers on a separate finalisation thread [todo
ref]. This is for two main reasons: first, a finaliser which needs to acquire a
lock will deadlock if ran on the same thread which already holds the lock;
second, the asynchronous nature of finalisers can cause interleaving
single-threaded code which races.

For these reasons, \ourgc finalises \lstinline{Gc<T>} values on a dedicated
finalisation thread, which requires \lstinline{T} to implement the
\lstinline{Send} marker trait. Figure~\ref{fig:finaliser_race} shows an example
of how finalising a non-\lstinline{Send} type off-thread is unsound. When
\lstinline{T} does not implement \lstinline{Send}, a collected \lstinline{Gc<T>}
will never be finalised. \ourgc will show a compiler warning lint to the user
explaining this.

Counterintuitively, it is permissable for rustgc to finalise
non-\lstinline{Sync} values off-thread. The \lstinline{Sync} trait is required
to reference a type from multiple threads simultaneuosly.  However, \ourgc's
\textit{dynamic liveness extension} guarantees that \textit{Gc} values are not
reclaimed early, so a value's finaliser will never run while it is still
reachable from a mutator thread. This allows finalisers to to access their
value's data without synchronisation.  \jake{todo: link to subsection about
inline asm which keeps values alive in mir}

This has the ergonomic benefit of allowing off-thread finalisation of GC'd
values with interior mutability using the \lstinline{RefCell} pattern. A
\lstinline{Gc<RefCell<T>>} implements \lstinline{Send} if \lstinline{T} does.
However, \lstinline{RefCell} does not implement \lstinline{Sync} because the
dynamic borrow checking it performs, which is implemented internally as a form
of reference counting, is not thread-safe.

\ourgc provides an \textit{escape hatch} to support the finalisation of
non-\lstinline{Send} values on the same thread which owns the value. Without
this, patterns such as \lstinline{Gc<Rc<T>>} would be unusable because the
\lstinline{Rc} would never be dropped and always leak memory. \footnote{While no garbage collector
can guarantee that finalisers are run, missed finalisers in \ourgc are rare in
practice, which make the mixing of garbage collected and reference counted
stategies both viable and useful.} The unsafe trait
\lstinline{FinaliseLocally} can be implemented on types, such as \lstinline{Rc}
where thread-local finalisation is desired. \jake{Bikeshed on the trait name}.
This is unsafe because the user must ensure that this trait is only
implemented on a a type where the drop implementation does not access any
data using synchronisation primitives. This is because it is not possible to
guarantee such accesses would be deadlock free due to the non-deterministic
execution of the finaliser.

\cite{jones16garbage}


\bibliographystyle{plain}
\bibliography{bib}

\end{document}
