%&rustgc_paper_preamble
\endofdump

\begin{document}
\maketitle

\begin{abstract}
Rust is a non-garbage collected language and existing attempts to add GC
support to it are either (subjectively) unergonomic, or (objectively)
unsound or slow. In this paper we show that it is possible to add a fairly
ergonomic GC to Rust without compromising soundness \laurie{is this true?}
\jake{no, to be really pedantic, it's not possible to make a completely
sound conservative GC because you can obfuscate pointers in safe Rust code}
\laurie{devil's advocate: since you can't deref pointers in safe Rust code, is it the case that we don't compromise the safety of \emph{safe} Rust code?}
\jake{I'm not sure I buy this. obfuscating pointers in safe code can lead to
use-after-frees when the user goes to deref Gc<T>s. So sure, Gc<T> is
implemented as an unsafe deref behind the scenes. However, we what we expose to
the user is a seemingly safe API via the Gc<T> type, and they will have unexpectedly broken preconditions for
Gc<T>::deref() by obfuscating some random pointer earlier on in safe rust code. This, in my view,
is unsound, but also impossible to fix/enforce}\laurie{how can you deref
a pointer without using \texttt{unsafe}?}
and with reasonable performance. This does require us to change the Rust
compiler and expose new APIs to the user, but we do not change the Rust
language itself.
\end{abstract}


\section{Introduction}

Amongst the several ways we can divide programming languages are whether they
are Garbage Collected (GCed) or not. Traditionally non-GCed languages have
required explicit memory management (e.g~\lstinline{C}'s \lstinline{malloc} /
\lstinline{free} functions). Rust's use of ownership types is a hybrid: most
memory management is implicit but it is not GCed. For many portions of many
programs, a Rust program looks identical, from a memory management perspective,
to a GCed language equivalent. However, some kinds of programs are frustrating
to write with ownership types, for examples programs with graph structures.
There are various ways of encoding such structures, and while Rust protects the
user from traditional mistakes such as dangling pointers, it cannot prevent
memory leaks.

Despite Rust's relative youth, there have been many attempts to add GC to it.
Most are user level libraries \laurie{cite the ones we know of, and outline the
major issues e.g.~can't GC across libraries etc.}. The Bronze
GC~\cite{coblenz21bronze} in contrast, performs GC at a lower-level (using LLVM
\lstinline{StackMaps}) but allows the aliasing of mutable values, undermining
Rust's soundness rules.

In this paper we introduce \ourgc, an ergonomic GC, that goes out of its way
to preserve soundness, while also not unduly compromising performance.
\laurie{outline the key techniques}


\section{Background}

\jake{TODO: Not sure where this stuff goes, or if it will ever make the cut}Rust uses two marker traits: `Send`, and `Sync` for handling concurrency. A type
which implements `Send' is safe to pass between threads, and a type which
implements `Sync' can be referenced from multiple threads at the same time.
These marker traits are implemented transitively; in other words, if a type
`T''s component types all implement `Send' and `Sync', then so will `T'.
Further, if any component type is not `Send' or `Sync', then neither is `T'.
These marker traits allow Rust to catch potential concurrency bugs statically
during type checking.

Rust allows for single-threaded shared ownership using a reference counting
smart pointer, `Rc<T>'. It updates the reference count non-atomically, it
can't implement `Send' because two threads could race when updating the count.

\section{Implementation}

\subsection{Finalisers and Destructors}

\subsection{Multi-threaded garbage collection}

In single-threaded GC, roots can only exist in three places: the
call stack, registers, and in the program's \emph{data segment} (for static
variables). In a multi-threaded GC, there are multiple call stacks, each
of which must be scanned for roots. This requires threads to cooperate in order
to make sure that this scanning can be done in a consistent fashion. The most
simple form of cooperation is to `stop the world', that is for threads to notice
when a global condition is set, and for them to voluntarily pause themselves.
\boehm uses this strategy, with threads checking whether they should pause
during memory allocation \laurie{GC\_alloc?} or \lstinline{force_gc}.
\jake{subtle difference: the mutator threads themselves don't poll to see if
they should pause. Instead, the collector forces them to by sending them signals
to wait on which are never usually used (e.g. SIGPWR / SIGBUS)} \laurie{ok.
so why do we say they also wait in GC\_alloc and force\_gc ?}

\ourgc patches
Rust's threading implementation to register/register threads on creation/destruction with \boehm.
on thread creation, and unregister when a thread is destroyed. To facilitate
pausing threads when the collector needs a consistent memory state, \ourgc uses
\boehm's signal spin implementation: when the collector thread wishes to stop the
world, it sends a SIGPWR signal to each registered thread and has them spin in a
signal handler until the collector has finished stopping the
world.\jake{cite} \laurie{is this something that \ourgc has added, or is this
spinning what \boehm does without our help?} \jake{This is all boehm}

This has two key limitations: first, \ourgc can only stop the world during
allocation and calls to \lstinline{force_gc} by a mutator thread; second, it
makes use of implementation-defined behaviour because it relies on the target
OS's mechanism for pausing threads. \boehm provides implementations for most
platforms, but it is not portable. An implementation where Rust inserts thread
pause safepoints at appropriate locations would largely solve these issues, with
considerable implementation effort.

\subsection{Off-thread Finalisation}

Most VMs implementations run finalisers on a separate finalisation thread [todo
ref]. This is for two main reasons: first, a finaliser which needs to acquire a
lock will deadlock if ran on the same thread which already holds the lock;
second, the asynchronous nature of finalisers can cause interleaving
single-threaded code which races.

For these reasons, \ourgc finalises \lstinline{Gc<T>} values on a dedicated
finalisation thread, which requires \lstinline{T} to implement the
\lstinline{Send} marker trait. Figure~\ref{fig:finaliser_race} shows an example
of how finalising a non-\lstinline{Send} type off-thread is unsound. When
\lstinline{T} does not implement \lstinline{Send}, a collected \lstinline{Gc<T>}
will never be finalised. \ourgc will show a compiler warning lint to the user
explaining this.

Counterintuitively, it is permissable for rustgc to finalise
non-\lstinline{Sync} values off-thread. The \lstinline{Sync} trait is required
to reference a type from multiple threads simultaneuosly.  However, \ourgc's
\textit{dynamic liveness extension} guarantees that \textit{Gc} values are not
reclaimed early, so a value's finaliser will never run while it is still
reachable from a mutator thread. This allows finalisers to to access their
value's data without synchronisation.  \jake{todo: link to subsection about
inline asm which keeps values alive in mir}

This has the ergonomic benefit of allowing off-thread finalisation of GC'd
values with interior mutability using the \lstinline{RefCell} pattern. A
\lstinline{Gc<RefCell<T>>} implements \lstinline{Send} if \lstinline{T} does.
However, \lstinline{RefCell} does not implement \lstinline{Sync} because the
dynamic borrow checking it performs, which is implemented internally as a form
of reference counting, is not thread-safe.

\begin{figure}[t]
\begin{lstlisting}
fn foo() {
    let x = Rc::new(123);
    {
        let y = Gc::new(Rc::clone(rc));
    }

    // Finalises unreachable values off-thread
    force_gc();

    let z = Rc::clone(rc);
}
\end{lstlisting}
\caption{An example of unsoundness when finalising values off-thread. Rust's
\lstinline{Rc} smart pointer is intended to be used for single-threaded
shared ownership so it updates its reference count non-atomically. The
\lstinline{force_gc} call on line 8 will cause the collector to reclaim
\lstinline{y} which is no longer reachable. \lstinline{y} will be finalised
off-thread, resulting in a call to \lstinline{Rc::drop(x)}. This is unsound
because it has the potential to race with the incref on the main-thread on
line 10.}
\label{fig:finaliser_race}
\end{figure}

\ourgc provides an \textit{escape hatch} to support the finalisation of
non-\lstinline{Send} values on the same thread which owns the value. Without
this, patterns such as \lstinline{Gc<Rc<T>>} would be unusable because the
\lstinline{Rc} would never be dropped and always leak memory. \footnote{While no garbage collector
can guarantee that finalisers are run, missed finalisers in \ourgc are rare in
practice, which make the mixing of garbage collected and reference counted
stategies both viable and useful.} The unsafe trait
\lstinline{FinaliseLocally} can be implemented on types, such as \lstinline{Rc}
where thread-local finalisation is desired. \jake{Bikeshed on the trait name}.
This is unsafe because the user must ensure that this trait is only
implemented on a a type where the drop implementation does not access any
data using synchronisation primitives. This is because it is not possible to
guarantee such accesses would be deadlock free due to the non-deterministic
execution of the finaliser.

\cite{jones16garbage}


\bibliographystyle{plain}
\bibliography{bib}

\end{document}
